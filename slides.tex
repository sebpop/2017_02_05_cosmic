\documentclass{beamer}
\def \sarccontrib {{\bf SARC contribution}}
\begin{document}
\title{Optimizing the software stack of a cosmic proportions cluster of multi-core machines}
\author{Sebastian Pop}
\institute{SARC: Samsung Austin R\&D Center}
\date{February 5, 2017}

\frame{\titlepage}

\frame{\frametitle{Android: a cosmic size cluster}
  \begin{itemize}
  \item top500: $10M$ cores / $15.3MW$ \footnote{\url{https://www.top500.org/lists/2016/11}} / US$\$273$ million \footnote{\url{https://en.wikipedia.org/wiki/Sunway_TaihuLight}}
  \item Android devices: $\sim{}6B$ cores \footnote{4 cores / device} / $\sim{}300MW$ \footnote{battery $13.2Wh = 4.4V * 3000 mAh$, charging every 48 hours} / $\sim{}$US\$0
  \includegraphics[width=8cm]{active-devices.png}
  \end{itemize}
}

\frame{\frametitle{Android Open Source Project (AOSP) Software Stack}
  \begin{itemize}
  \item<1-> AOSP: common base for Android devices (+ customizations)
  \item<1-> C/C++ for the platform libraries, Java for user interface
    {\small \begin{tabular}{c c c}
      ansic & 22 MLoC & 39\% \\
      cpp   & 13 MLoC & 23\% \\
      java  & 10 MLoC & 17\% \\
    \end{tabular}}
  \item<1-> $\sim80\%$ execution cycles in C/C++, $\sim20\%$ in Java
  \item<2-> release/updates/deprecation ($5\sim6$ years) \\
    \includegraphics[width=8cm]{android-versions.png} \footnote{Data collected during a 7-day period ending on January 9, 2017.}
  \end{itemize}
}

\frame{\frametitle{Why Optimizing the Performance of Android?}
  \onslide<1-> {
    Why bothering?
    \begin{itemize}
    \item the code of Android is cold (flat profile), full of branches
    \item there are few loops (image processing, compression, etc.)
    \end{itemize}
  }
  \vspace{.3cm}
  \onslide<2-> {
    Motivation:
    \begin{itemize}
    \item same code executed billions of time
    \item outer loop is outside the device
    \item profile how often code is in use
    \item variation over time following popularity of apps
    \item continuously monitor usage patterns
    \item tune code optimziations over time
    \end{itemize}
    \vspace{.3cm}
    \begin{tabular}{c c c}
      $\$0.30$ / device / year & $\longrightarrow$ & $\$300M$ / billion devices / year \footnote{$\$0.12/kWh$, battery $13.2Wh = 4.4V * 3000 mAh$, charging every 48 hours} \\
      \includegraphics[width=1.5cm]{1watt.jpg} & & \includegraphics[width=3cm]{1GWatt.jpg}
    \end{tabular}
  }
}

\frame{\frametitle{Agenda}
  \begin{itemize}
  \item Performance analysis: hot spots
  \item Improve performance of AOSP libraries
  \item Enable continuous profiling and optimizations (AutoFDO)
  \item Enable more secure execution environments (CFI)
  \end{itemize}
}

\frame{\frametitle{Performance Analysis}
  \begin{itemize}
  \item benchmarks: track performance over time (compiler/libraries)
  \item linux perf: profile of cycles (per function, hot-spots)
  \item valgrind: number of executed instructions (branches, R/W)
  \item static profiles: how many uses for a function
  \end{itemize}
}

\frame{\frametitle{Benchmarks}
  track performance (compiler/libraries) over time \\
  \includegraphics[width=11cm]{benchmarks.png}  
}

\frame{\frametitle{Benchmarks}
  on a real device (and a noisy benchmark...)
  \includegraphics[width=11cm]{benchmarks-device.png}
}

\frame{\frametitle{Linux Perf}
  
}

\frame{\frametitle{Valgrind}
  
}

\frame{\frametitle{Static Profile}
  \begin{itemize}
  \item -flto: static call-graph, estimated frequencies per call
  \end{itemize}
}

\frame{\frametitle{Improve performance of AOSP libraries}
  \sarccontrib{\bf s}
  \begin{itemize}
  \item update Android NDK libc++, make it easy to keep updated
  \item 20x speedup of std::string.find() in libc++ and libstdc++
    need to port perf to memmem and strstr of bionic and glibc
  \item improve perf of shared\_ptr in libc++
  \item improve perf of string to int value parsing in libc++
  \end{itemize}
}

\frame{\frametitle{Benchmarking Standard Libraries}
  \sarccontrib{}: std-benchmark\footnote{https://github.com/hiraditya/std-benchmark}
  \vspace{1cm}
  \begin{itemize}
  \item std-benchmark provides micro-benchmarks for functions in libc and C++ standard library
  \item detect room for improvement
    \begin{itemize}
    \item compile with different compilers
    \item link with different standard libraries
    \item run on different machines: CPUs, architectures
    \end{itemize}
  \end{itemize}
}

\frame{\frametitle{AutoFDO: Feedback Directed Optimization}
  \begin{itemize}
  \item linux-perf extracts profiles of running systems
  \item little to no overhead \footnote{Google Wide Profiling: A Continuous Profiling Infrastructure for Data Centers, IEEE Micro (2010)}
  \item coverage (basic block frequencies) from dynamic profiles
  \item continuous profiling and tuning of optimizations
    \includegraphics[width=5cm]{continuous-autofdo.eps}
  \end{itemize}
}

\frame{\frametitle{AutoFDO: Example}
  \includegraphics[width=11cm]{autofdo.eps}
}

\frame{\frametitle{AutoFDO: Code Optimizations}
  \begin{itemize}
  \item better inlining \footnote{Lightweight Feedback-Directed Cross-Module Optimization, CGO 2010}, devirtualization, function instantiation
  \item hot/cold code placement
  \item register allocation, jump-threading, etc.
  \end{itemize}
}

\frame{\frametitle{AutoFDO: More Precise Coverage}
  \begin{itemize}
  \item Intel-LBR (Last Branch Record): last 16 taken branches
  \item provides more precise basic block execution frequency
  \item how do we do this on ARM?
  \end{itemize}
}

\frame{\frametitle{ARM-ETM: Embedded Trace Macrocell}
  \begin{itemize}
  \item ARM-ETM: records execution traces (for debug)
  \item dedicated circular buffer 1 to 3MB ($\sim10^5$ branches/MB)
  \item no overhead
  \item support in Linux kernel by Mathieu Poirier (Linaro)
  \item next android kernel linux-4.9 will support ARM-ETM
    \vspace{1cm}
  \item \sarccontrib{:} how to use ARM-ETM for AutoFDO
    \begin{itemize}
    \item perf-inject translates execution traces to LBR events
    \item patch similar to perf-inject for Intel Process Trace
    \end{itemize}
  \end{itemize}
}

\frame{\frametitle{AutoFDO: with ARM-ETM}
  \includegraphics[width=10cm]{autofdo-etm.eps}
}

\frame{\frametitle{From Dynamic Profiles to Power Usage}
  \begin{itemize}
  \item traditionally, per app battery usage (ammeter on wire) \footnote{An Analysis of Power Consumption in a Smartphone, USENIX'10}
  \item more accurate picture with linux-perf profiles:
    \begin{itemize}
    \item profiles from the field: real world use-cases
    \item merge together different profiles
    \item compute code execution frequency
    \item power consumption estimation per line of code
    \end{itemize}
  \end{itemize}
}

\frame{\frametitle{Towards more secure devices}
  \begin{itemize}
  \item Control Flow Integrity (CFI): $2\%$ overhead \footnote{Enforcing Forward-Edge Control-Flow Integrity in GCC\&LLVM, USENIX'14}
  \item to enable on Android: need to further reduce its cost
  \end{itemize}
}

\end{document}
